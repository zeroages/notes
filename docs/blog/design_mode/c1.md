> ### 一、设计模式类型

   分为三种类型，共23种

（1）创建型（单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式）

（2）结构型（适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式）

（3）行为型 （模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式）

>### 二、设计模式七大原则

（1）单一职责原则：就一个类而言，应该仅有一个引起它变化的原因

（2）开放-封闭原则：软件实体可以拓展但是不可以修改

（3）依赖倒转原则：高层模块和低层模块两者都应依赖抽象；抽象不应依赖细节，细节依赖抽象，换言之，要针对接口编程，而不是针对实现编程

（4）里氏代换原则：所有引用父类的地方必须能够透明地使用其子类的对象

（5）合成聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承

（6）迪米特原则：一个对象应该对其他对象保持最少的了解。不跟陌生人说话

（7）接口隔离原则：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上

>### 三、创建型模式

#### 1、单例模式

（1）饿汉式 

类加载时候创建对象，可能造成内存浪费

构造器私有化，外部不能new，创建公有静态方法，返回实例对象

java.lang.Runtime就是经典的单例模式

（2）懒汉式 

​       线程不安全

​       提供一个静态公共方法，调用该方法时才去创建对象

​       解决线程不安全：同步代码块，volatile关键字声明静态实例变量；

 （3）静态内部类

​         内部类中静态属性为外部类名，并实例化外部类

​         提供静态公有方法，直接返回静态内部类属性 

  小结：

（1）单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例可以提高系统性能

（2）单例模式使用场景：需要频繁进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、工具类、频繁访问      数据库或文件的对象（比如数据源、session工厂等）

#### 2、工厂模式

（1）简单工厂模式 

​   ①由一个工厂对象决定创建出哪一种产品类的实例

   ②定义了一个创建对象的类，由这个类来封装实例化对象的行为

   ③大量的创建某种、某类或者某批对象时，就会使用到工厂模式

（2）抽象工厂模式

  java.util.calendar经典抽象工厂模式

​	    ①定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类，由继承接口的子类去具体实现

​	    ②将工厂抽象成两层，AbsFactory（抽象工厂）和具体实现的工厂子类，这样将单个的简单工厂类变成工厂簇，更利于代码的维护和扩展

小结：

（1）工厂模式的意义

  将实例化对象提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系解耦，从而提高项目的扩展和维护性

（2）设计模式的依赖抽象原则

  创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回

  不要让类继承具体类，而是继承抽象类或者是实现接口

  不要覆盖基类中已经实现的方法

#### 3、原型模式

  （1）原型模式是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象


  jDK中Object类提供了一个clone方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须实现一个接口cloneable，该接口表示该类能够复制且具有复制的能力

  spring中原型bean的创建，就是原型模式的应用，scope=“prototype”

  （2）浅拷贝和深拷贝

  <b>浅拷贝</b>

  ①基本类型的成员变量，浅拷贝会直接进行值传递

  ②引用类型的成员变量，数组、对象等，浅拷贝会进行引用传递，也就是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。
  在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值

  ③浅拷贝是使用默认的clone方法实现 super.clone()

  <b>深拷贝</b>

  ①重写clone方法实现深拷贝

  ②通过对象序列化实现深拷贝

#### 4、建造者模式




